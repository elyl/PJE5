<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>PJE5 - Lheureux Axel, Yuan Yao by elyl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PJE5 - Lheureux Axel, Yuan Yao</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/elyl/PJE5" class="btn">View on GitHub</a>
      <a href="https://github.com/elyl/PJE5/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/elyl/PJE5/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="séance-1--découverte-de-lenvironement" class="anchor" href="#s%C3%A9ance-1--d%C3%A9couverte-de-lenvironement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 1 : découverte de l'environement</h1>

<h2>
<a id="utilisation-du-microcontroleur" class="anchor" href="#utilisation-du-microcontroleur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilisation du microcontroleur</h2>

<p>Nous avons commencé la première séance par des recherches sur le fonctionement du microcontroleur fourni dans le cadre du projet.
Nous avons commencé par rechercher un outil suceptible de nous permettre de compiler des programmes pour ce microcontroleur. Pour des raisons pratiques les recherches se sont d'abord orientées vers un compilateur local (gcc par exemple) mais il ne semblait pas possible d'en trouver un suceptible d'être installé sur nos machines (manque de permissions). Nous nous sommes donc rabbatus sur le compilateur en ligne de mbed.
Au moment de transférer le programme sur la tablette il s'est avéré que, pour une raison inconnue, celle ci était en mode "lecture seule", il a donc fallut la formater avant de pouvoir tester nos programmes.</p>

<p>Une fois le premier programme d'exemple actif nous avons essayé de le modifier afin d'allumer les autres LEDs, les LEDs 2 et 4 ne semblent pas fonctionner correctement, il faudra poursuivre les recherches dans cette direction pôur identifier la cause de ce dysfonctionnement.</p>

<h2>
<a id="montage-des-leds" class="anchor" href="#montage-des-leds" aria-hidden="true"><span class="octicon octicon-link"></span></a>Montage des LEDs</h2>

<p>La deuxième partie de la séance a été consacrée à essayer (avec succès !) d'allumer une puis plusieurs LEDs à l'aide du microcontroleur. Après quelques révisions d'électricité et une étude rapide des documents fournis avec le matiériel cela s'est avéré assez rapide et simple. Notre seul problème fut d'identifier le bon sens de branchement pour le circuit.
En fin de séance nous pouvions allumer plusieurs LEDs à l'aide d'un programme chargé sur le microcontroleur.</p>

<h1>
<a id="séance-2--compilation-en-local" class="anchor" href="#s%C3%A9ance-2--compilation-en-local" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 2 : compilation en local</h1>

<h2>
<a id="recherche-de-solutions" class="anchor" href="#recherche-de-solutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recherche de solutions</h2>

<p>Le but de cette séance était de trouver une solution permettant de compiler du code pour le microcontroleur directement depuis le poste local. Nous avons d'abord chercher les solutions proposées par le constucteur mais toutes nécessitaient d'installer de nouveaux paquets sur les machines ce qui n'était pas envisageable.
Nous avons trouvé une solution qui reposait sur des paquets déjà installés sur les machines de l'université (Le compilateur gcc pour ARM entre autre) mais il nous manquait une API nous avons donc laisser cette solution de côté pour essayer d'autres choses avant de peut être y revenir par la suite en l'absence d'autres solutions.</p>

<h2>
<a id="rflpc" class="anchor" href="#rflpc" aria-hidden="true"><span class="octicon octicon-link"></span></a>RFLPC</h2>

<p>Après un certain temps de rechercher nous avons finalement trouvé une solution permettant de compiler notre code localement facilement, la lib RFLPC écrite par Michaël Hauspie. Cette solution founit tout un ensembles de fonctions pour contrôler le microcontroleur ainsi qu'un bon nombre d'exemples illustrant de nombreux aspects de cette API.
Nous sommes parvenus à reproduire les exemples du TP précédent après quelques minutes de recherches seulement une fois l'API découverte.</p>

<h1>
<a id="sécance-3-" class="anchor" href="#s%C3%A9cance-3-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sécance 3 :</h1>

<p>Au début, nous avons trouvée le document main.c dans le fichier samples/skel. Chaque fois, nous le modifions et compilons. Nous cherchons dans la libraire et trouvons des méthode comme &lt;&gt; pour allumer le LED. Il y a aussi une difficulté de trouver à quoi les pins du microcontrôleur dans le pinconf.h, c'est pour contrôler la porte. Après, nous utilisions des méthodes dans gpio.h pour contrôle le fréquence.</p>

<h1>
<a id="séance-4--utilisation-du-controleur-ethernet" class="anchor" href="#s%C3%A9ance-4--utilisation-du-controleur-ethernet" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 4 : Utilisation du controleur ethernet</h1>

<h2>
<a id="découverte-de-lapi-et-programme-simple" class="anchor" href="#d%C3%A9couverte-de-lapi-et-programme-simple" aria-hidden="true"><span class="octicon octicon-link"></span></a>Découverte de l'API et programme simple</h2>

<p>Le premier objectif de la séance était d'allumer une LED sur le MBED lors du branchement d'un câble ethernet sur le contrôleur ethernet founit. Après une rapide recherche dans l'API nous avons trouvé les fonctions permettant de gérer un tel contrôleur et nous avons commencé l'écriture d'un simple programme. Ce programme se contentait de vérifier en boucle l'état du lien ethernet et il allumait ou éteignait une LED en fonction de la présence ou non d'un lien actif.</p>

<h2>
<a id="programme-plus-avancé-et-limitations-du-matériel" class="anchor" href="#programme-plus-avanc%C3%A9-et-limitations-du-mat%C3%A9riel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Programme plus avancé et limitations du matériel</h2>

<p>Nous avons ensuite voulu créer un programme plus avancé permettant de détecter le branchement d'un câble ethernet pendant que le programme poursuivait son éxécution normale et ne se concentrait plus uniquement sur la détection du câble. Nous avons décidé d'utiliser le mécanisme des intertuptions proposé par l'API. Lorsqu'un câble est branché une interruption est générée et peut être traitée par le programme.
La réalisation de ce programme ne prit que quelques minutes mais sa vérification fut beaucoup plus longue, en effet le branchement du contrôleur ethernet est plutôt capricieux et bien souvent il n'est pas branché correctement empêchant de fait le fonctionnement correct du programme. Au bout de longues minutes de tests et de changements de controleurs et de postes nous sommes parvenus à faire fonctionner le programme allumant une LED au branchement d'un câble ethernet à l'aide d'interruptions.</p>

<h1>
<a id="séance-5-découverte-de-smews" class="anchor" href="#s%C3%A9ance-5-d%C3%A9couverte-de-smews" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 5: Découverte de Smews</h1>

<h2>
<a id="compilation-de-smews-et-des-applications" class="anchor" href="#compilation-de-smews-et-des-applications" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compilation de Smews et des applications</h2>

<p>Cette séance fut consacrée à l'installation et la découverte du serveur web embarqué Smews. La Téléchargement et la compilation de Smews sur les machines ne posa aucun problème contrairement à l'étape suivant qui était d'associer la biblithèque rflpc avec Smews afin de compiler les applications pour mbed.
Tout d'abord nous avons essayé de simplement faire appel au script "summon_rflpc" fourni avec Smews mais sans succès.Ensuite nous avons essayé d'indiquer manuellement à Smews un chemin vers rflpc téléchargé et compilé manuellement, toujours sans succès. Après avoir perdu de très longues minutes sur ce problème nous avons découvert que la seule solution pour que le script "summon_rflpc" parvienne à passer le proxy de l'université était de cloner depuis Github les sources de Smews (et non plus depuis le site officiel) et de compiler à partir de là.</p>

<h2>
<a id="première-application" class="anchor" href="#premi%C3%A8re-application" aria-hidden="true"><span class="octicon octicon-link"></span></a>Première application</h2>

<p>Une fois l'application compilée il ne restait plus qu'à l'éxécuter et constater son bon fonctionnement. Il fallait pour ça modifier les tables de routages de notre machine afin de pouvoir se connecter au mbed et accèder au serveur web. Cette étape fut extrêment longue en raison de deux problèmes en particulier. Le premier déjà connu venait du manque de fiabilité du contrôleur ethernet pour le mbed. Le second problème est venu du fait que notre machine refusait de mettre à jour correctement les tables de routage dans un premier temps (probablement dû à une mauvaise manipulation précédement), le problème fût finalement résolu grâce à un reboot.
Tous ces problèmes (Contrôleur ethernet, tables de routage et proxy) ont fait que nous n'avons malheureusement pas eu le temps de tester un autre programme que le programme "welcome" fourni en exemple avec Smews.</p>

<h1>
<a id="séance-6--nouvelle-plaquette" class="anchor" href="#s%C3%A9ance-6--nouvelle-plaquette" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 6 : Nouvelle plaquette</h1>

<p>Lors de cette séance une extension pour la plaquette mbed nous fut procurée. Celle ci embarque, en vrac, un contrôleur ethernet, un écran lcd, un joystick etc.
Le nouveau contrôleur ethernet étant fiable nous avons pu continuer les expérimentations avec Smews. L'inégralité de la séance fût consacrée à réaliser le tutoriel de Smews fourni avec la documentation officielle. Peu de difficultées majeures recontrées, quelques imprécisions de la documentation mais rien de plus.</p>

<h1>
<a id="séance-7--application-plus-évoluée" class="anchor" href="#s%C3%A9ance-7--application-plus-%C3%A9volu%C3%A9e" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 7 : Application plus évoluée</h1>

<p>Le but de cette séance était de commencer à utiliser les périphériques disponibles sur l'application board avec pour objectif final de réaliser une application qui va afficher sur le navigateur des informations en provenance d'un ou plusieurs périphériques. Nous avons décidé d'essayer de travailler avec le thermomère (Au hasard, il fallait bien prendre quelque chose) qui utilise le protocole I2C. RFLPC fourni des fonctions pour manipuler ce protocole à bas niveau nous avons donc dû nous renseigner sur le fonctionnement du protocole et essayer des choses. Pour le moment nous n'avons pas grand chose...</p>

<h1>
<a id="séance-8--le-protocole-i2c" class="anchor" href="#s%C3%A9ance-8--le-protocole-i2c" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 8 : Le protocole I2C</h1>

<p>Le but de cette séance sera de continuer les recherches sur le fonctionnement du protocole I2C avec pour objectif de parvenir à interagir avec la plaquette.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/elyl/PJE5">PJE5 - Lheureux Axel, Yuan Yao</a> is maintained by <a href="https://github.com/elyl">elyl</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
