<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>PJE5 - Lheureux Axel, Yuan Yao by elyl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PJE5 - Lheureux Axel, Yuan Yao</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/elyl/PJE5" class="btn">View on GitHub</a>
      <a href="https://github.com/elyl/PJE5/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/elyl/PJE5/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="séance-1--découverte-de-lenvironement" class="anchor" href="#s%C3%A9ance-1--d%C3%A9couverte-de-lenvironement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 1 : découverte de l'environement</h1>

<h2>
<a id="utilisation-du-microcontroleur" class="anchor" href="#utilisation-du-microcontroleur" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilisation du microcontroleur</h2>

<p>Nous avons commencé la première séance par des recherches sur le fonctionement du microcontroleur fourni dans le cadre du projet.
Nous avons commencé par rechercher un outil suceptible de nous permettre de compiler des programmes pour ce microcontroleur. Pour des raisons pratiques les recherches se sont d'abord orientées vers un compilateur local (gcc par exemple) mais il ne semblait pas possible d'en trouver un suceptible d'être installé sur nos machines (manque de permissions). Nous nous sommes donc rabbatus sur le compilateur en ligne de mbed.
Au moment de transférer le programme sur la tablette il s'est avéré que, pour une raison inconnue, celle ci était en mode "lecture seule", il a donc fallut la formater avant de pouvoir tester nos programmes.</p>

<p>Une fois le premier programme d'exemple actif nous avons essayé de le modifier afin d'allumer les autres LEDs, les LEDs 2 et 4 ne semblent pas fonctionner correctement, il faudra poursuivre les recherches dans cette direction pôur identifier la cause de ce dysfonctionnement.</p>

<h2>
<a id="montage-des-leds" class="anchor" href="#montage-des-leds" aria-hidden="true"><span class="octicon octicon-link"></span></a>Montage des LEDs</h2>

<p>La deuxième partie de la séance a été consacrée à essayer (avec succès !) d'allumer une puis plusieurs LEDs à l'aide du microcontroleur. Après quelques révisions d'électricité et une étude rapide des documents fournis avec le matiériel cela s'est avéré assez rapide et simple. Notre seul problème fut d'identifier le bon sens de branchement pour le circuit.
En fin de séance nous pouvions allumer plusieurs LEDs à l'aide d'un programme chargé sur le microcontroleur.</p>

<h1>
<a id="séance-2--compilation-en-local" class="anchor" href="#s%C3%A9ance-2--compilation-en-local" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 2 : compilation en local</h1>

<h2>
<a id="recherche-de-solutions" class="anchor" href="#recherche-de-solutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recherche de solutions</h2>

<p>Le but de cette séance était de trouver une solution permettant de compiler du code pour le microcontroleur directement depuis le poste local. Nous avons d'abord chercher les solutions proposées par le constucteur mais toutes nécessitaient d'installer de nouveaux paquets sur les machines ce qui n'était pas envisageable.
Nous avons trouvé une solution qui reposait sur des paquets déjà installés sur les machines de l'université (Le compilateur gcc pour ARM entre autre) mais il nous manquait une API nous avons donc laisser cette solution de côté pour essayer d'autres choses avant de peut être y revenir par la suite en l'absence d'autres solutions.</p>

<h2>
<a id="rflpc" class="anchor" href="#rflpc" aria-hidden="true"><span class="octicon octicon-link"></span></a>RFLPC</h2>

<p>Après un certain temps de rechercher nous avons finalement trouvé une solution permettant de compiler notre code localement facilement, la lib RFLPC écrite par Michaël Hauspie. Cette solution founit tout un ensembles de fonctions pour contrôler le microcontroleur ainsi qu'un bon nombre d'exemples illustrant de nombreux aspects de cette API.
Nous sommes parvenus à reproduire les exemples du TP précédent après quelques minutes de recherches seulement une fois l'API découverte.</p>

<h1>
<a id="sécance-3-" class="anchor" href="#s%C3%A9cance-3-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sécance 3 :</h1>

<h1>
<a id="séance-4--utilisation-du-controleur-ethernet" class="anchor" href="#s%C3%A9ance-4--utilisation-du-controleur-ethernet" aria-hidden="true"><span class="octicon octicon-link"></span></a>Séance 4 : Utilisation du controleur ethernet</h1>

<h2>
<a id="découverte-de-lapi-et-programme-simple" class="anchor" href="#d%C3%A9couverte-de-lapi-et-programme-simple" aria-hidden="true"><span class="octicon octicon-link"></span></a>Découverte de l'API et programme simple</h2>

<p>Le premier objectif de la séance était d'allumer une LED sur le MBED lors du branchement d'un câble ethernet sur le contrôleur ethernet founit. Après une rapide recherche dans l'API nous avons trouvé les fonctions permettant de gérer un tel contrôleur et nous avons commencé l'écriture d'un simple programme. Ce programme se contentait de vérifier en boucle l'état du lien ethernet et il allumait ou éteignait une LED en fonction de la présence ou non d'un lien actif.</p>

<h2>
<a id="programme-plus-avancé-et-limitations-du-matériel" class="anchor" href="#programme-plus-avanc%C3%A9-et-limitations-du-mat%C3%A9riel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Programme plus avancé et limitations du matériel</h2>

<p>Nous avons ensuite voulu créer un programme plus avancé permettant de détecter le branchement d'un câble ethernet pendant que le programme poursuivait son éxécution normale et ne se concentrait plus uniquement sur la détection du câble. Nous avons décidé d'utiliser le mécanisme des intertuptions proposé par l'API. Lorsqu'un câble est branché une interruption est générée et peut être traitée par le programme.
La réalisation de ce programme ne prit que quelques minutes mais sa vérification fut beaucoup plus longue, en effet le branchement du contrôleur ethernet est plutôt capricieux et bien souvent il n'est pas branché correctement empêchant de fait le fonctionnement correct du programme. Au bout de longues minutes de tests et de changements de controleurs et de postes nous sommes parvenus à faire fonctionner le programme allumant une LED au branchement d'un câble ethernet à l'aide d'interruptions.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/elyl/PJE5">PJE5 - Lheureux Axel, Yuan Yao</a> is maintained by <a href="https://github.com/elyl">elyl</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
